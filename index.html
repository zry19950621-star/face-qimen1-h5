<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
  />
  <title>é­”æ³•åœ£è¯æ ‘ - è½»é‡ç‰ˆ</title>

  <!-- Three.js & OrbitControls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <!-- MediaPipeï¼ˆæ‰‹åŠ¿è¯†åˆ«ï¼‰-->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #1b2735 0%, #090a0f 100%);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui,
        sans-serif;
      color: #fff;
    }

    #canvas-container {
      position: absolute;
      inset: 0;
      z-index: 1;
    }

    #ui-layer {
      position: absolute;
      inset: 0;
      z-index: 10;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 16px;
    }

    .interactive-element {
      pointer-events: auto;
    }

    #webcam-preview {
      position: absolute;
      bottom: 16px;
      right: 16px;
      width: 140px;
      height: 100px;
      border-radius: 12px;
      border: 2px solid rgba(255, 215, 0, 0.5);
      transform: scaleX(-1);
      opacity: 0.8;
      box-shadow: 0 0 12px rgba(255, 215, 0, 0.3);
      z-index: 20;
      background: #000;
      object-fit: cover;
    }

    .glass-panel {
      background: rgba(18, 24, 38, 0.7);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
    }

    .loader {
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-top: 4px solid #ffd700;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }

    .glow-text {
      text-shadow: 0 0 10px #ffaa00, 0 0 20px #ff6600;
    }

    #gesture-status {
      transition: all 0.3s ease;
    }

    .size-radio:checked + span {
      color: #ffd700;
      font-weight: 600;
      text-shadow: 0 0 5px #ffaa00;
    }

    .rotate-180 {
      transform: rotate(180deg);
    }

    /* å¾®ä¿¡æç¤ºæ¡ */
    #wechat-tip-bar {
      z-index: 60;
    }
  </style>
</head>
<body>
  <!-- å¾®ä¿¡ç¯å¢ƒæç¤ºæ¡ -->
  <div
    id="wechat-tip-bar"
    class="hidden fixed top-0 left-0 right-0 px-3 py-2 bg-black/80 text-[11px] text-yellow-200 flex items-center justify-center gap-2"
  >
    <span>âš ï¸ å½“å‰åœ¨å¾®ä¿¡ä¸­æ‰“å¼€ï¼Œæ‰‹åŠ¿é­”æ³•å¯èƒ½å—é™</span>
    <span class="font-bold">è¯·ç‚¹å³ä¸Šè§’ Â·Â·Â· â†’ åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€</span>
  </div>

  <div id="canvas-container"></div>

  <video id="webcam-preview" playsinline muted class="hidden"></video>

  <div id="ui-layer">
    <!-- é¡¶éƒ¨åŒºåŸŸ -->
    <div class="flex justify-between items-start w-full gap-2">
      <!-- å·¦ä¸Šäº¤äº’é¢æ¿ï¼ˆå¯æŠ˜å ï¼‰ -->
      <div
        id="main-control-panel"
        class="glass-panel interactive-element max-w-md w-[80vw] sm:w-auto relative transition-all duration-300"
      >
        <!-- æŠ˜å æŒ‰é’® -->
        <button
          id="toggle-panel-btn"
          class="absolute top-2 right-2 text-white/60 hover:text-white z-50 p-1 transition-transform duration-300"
          title="æŠ˜å /å±•å¼€"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-5 w-5"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M19 9l-7 7-7-7"
            />
          </svg>
        </button>

        <!-- é¢æ¿å®Œæ•´å†…å®¹ -->
        <div id="panel-content">
          <!-- ç‚¹å‡»æ ‡é¢˜ä¹Ÿå¯æŠ˜å  -->
          <div id="panel-header" class="cursor-pointer mb-3 select-none">
            <h1 class="text-2xl sm:text-3xl font-bold text-yellow-100 glow-text">
              âœ¨ è¾‰å…‰åœ£è¯æ ‘
            </h1>
            <p class="text-xs sm:text-sm text-gray-200 mt-1">
              ä¸Šä¼ ä½ çš„ç…§ç‰‡å˜æˆæŒ‚é¥°ï¼Œç”¨æ‰‹åŠ¿è®©æ˜Ÿå…‰é£æ•£ / æ±‡èšã€‚<br />
              <span class="text-[11px] text-yellow-300"
                >æç¤ºï¼šæ‹–åŠ¨å¯æ—‹è½¬è§†è§’ Â· åŒæŒ‡ç¼©æ”¾</span
              >
            </p>
          </div>

          <!-- æŒ‚é¥°å°ºå¯¸é€‰æ‹© -->
          <div class="mb-3 p-2 bg-white/5 rounded-lg border border-white/10">
            <span class="text-xs text-yellow-200 mr-2 font-bold">æŒ‚é¥°å°ºå¯¸:</span>
            <label
              class="inline-flex items-center mr-3 cursor-pointer group text-xs sm:text-sm"
            >
              <input
                type="radio"
                name="photoSize"
                value="small"
                checked
                class="size-radio accent-yellow-500 h-4 w-4 cursor-pointer"
              />
              <span class="ml-1 text-gray-300 group-hover:text-white transition"
                >å°</span
              >
            </label>
            <label
              class="inline-flex items-center mr-3 cursor-pointer group text-xs sm:text-sm"
            >
              <input
                type="radio"
                name="photoSize"
                value="medium"
                class="size-radio accent-yellow-500 h-4 w-4 cursor-pointer"
              />
              <span class="ml-1 text-gray-300 group-hover:text-white transition"
                >ä¸­</span
              >
            </label>
            <label
              class="inline-flex items-center cursor-pointer group text-xs sm:text-sm"
            >
              <input
                type="radio"
                name="photoSize"
                value="large"
                class="size-radio accent-yellow-500 h-4 w-4 cursor-pointer"
              />
              <span class="ml-1 text-gray-300 group-hover:text-white transition"
                >å¤§</span
              >
            </label>
          </div>

          <!-- ä¸Šä¼  & é‡ç½® -->
          <div class="flex flex-wrap gap-2 items-center mb-3">
            <label
              class="cursor-pointer bg-yellow-500 hover:bg-yellow-600 text-black font-semibold py-2 px-4 rounded-full transition shadow-[0_0_12px_rgba(255,200,0,0.6)] flex items-center gap-2 text-xs sm:text-sm"
            >
              <span>ğŸ“· æ·»åŠ ç…§ç‰‡æŒ‚é¥°</span>
              <input
                type="file"
                id="image-upload"
                accept="image/*"
                class="hidden"
                multiple
              />
            </label>
            <button
              id="reset-photos-btn"
              class="bg-red-500/80 hover:bg-red-600 text-white font-semibold py-2 px-3 rounded-full transition shadow-lg text-xs sm:text-sm"
              title="æ¸…ç©ºæ‰€æœ‰ç…§ç‰‡"
            >
              ğŸ—‘ï¸ æ¸…ç©º
            </button>
            <span
              id="photo-count"
              class="text-[11px] sm:text-xs text-yellow-200 ml-1"
              >å·²æ·»åŠ  0 å¼ </span
            >
          </div>

          <!-- æ‰‹åŠ¿è¯´æ˜ -->
          <div
            class="bg-black/40 rounded-lg p-3 text-[11px] sm:text-xs border border-yellow-500/30 space-y-2"
          >
            <div class="flex items-center gap-2">
              <span class="text-xl">ğŸ–ï¸</span>
              <div>
                <div class="font-bold text-yellow-300">
                  å¼ å¼€äº”æŒ‡ï¼ˆSCATTERï¼‰
                </div>
                <div>æ˜Ÿå…‰é£æ•£ï¼Œç…§ç‰‡éšæ ‘ä¸€èµ·æ¼‚æµ®åœ¨ç©ºä¸­</div>
              </div>
            </div>
            <div class="flex items-center gap-2">
              <span class="text-xl">âœŠ</span>
              <div>
                <div class="font-bold text-green-300">æ¡ç´§æ‹³å¤´ï¼ˆGATHERï¼‰</div>
                <div>æ‰€æœ‰æŒ‚é¥°å›å½’åœ£è¯æ ‘ï¼Œé‡æ–°å›¢èš</div>
              </div>
            </div>
          </div>
        </div>

        <!-- æŠ˜å åçš„å°æ¡ -->
        <div
          id="panel-minimized"
          class="hidden pr-8 cursor-pointer h-8 flex items-center"
        >
          <h2
            class="text-sm font-bold text-yellow-100 glow-text flex items-center gap-2"
          >
            <span>âš™ï¸</span><span>è®¾ç½®é¢æ¿</span>
          </h2>
        </div>
      </div>

      <!-- å³ä¸ŠçŠ¶æ€æŒ‡ç¤ºå™¨ -->
      <div id="gesture-status" class="glass-panel hidden p-2 interactive-element">
        <div class="flex items-center gap-2">
          <div id="status-icon" class="text-xl">âœ¨</div>
          <div>
            <div
              class="text-[10px] uppercase tracking-wider text-yellow-300 mb-0.5"
            >
              å½“å‰çŠ¶æ€
            </div>
            <div id="status-text" class="text-xs font-bold text-white">
              ç­‰å¾…å¯åŠ¨æ‰‹åŠ¿é­”æ³•â€¦
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- ä¸­é—´ç©ºç™½å ä½ï¼Œè®©ä¸Šé¢å’Œä¸‹é¢ç•™ç©ºé—´ -->

    <!-- åº•éƒ¨ï¼šåŠ è½½ / å¯åŠ¨æŒ‰é’® -->
    <div
      id="loading-overlay"
      class="absolute inset-0 flex flex-col items-center justify-center bg-black/85 z-50 interactive-element"
    >
      <div class="loader mb-4"></div>
      <h2 class="text-lg font-bold text-yellow-100">æ­£åœ¨å¸ƒç½®åœ£è¯æ ‘èˆå°â€¦</h2>
      <p class="text-xs text-gray-300 mt-2">
        é¦–æ¬¡åŠ è½½ 3D åœºæ™¯å¯èƒ½éœ€è¦å‡ ç§’é’Ÿï¼Œè¯·ç¨å€™
      </p>
      <button
        id="start-btn"
        class="mt-6 px-8 py-3 bg-yellow-500 hover:bg-yellow-600 text-black font-bold rounded-full transition transform hover:scale-105 shadow-[0_0_16px_rgba(255,200,0,0.7)] text-sm"
      >
        å¯åŠ¨æ‰‹åŠ¿é­”æ³•ï¼ˆå¯é€‰ï¼‰
      </button>
      <p class="text-[11px] text-gray-400 mt-2">
        å¦‚æœä¸æƒ³å¼€æ‘„åƒå¤´ï¼Œä¹Ÿå¯ä»¥ç›´æ¥å…³é—­æ­¤æç¤ºå¼€å§‹æµè§ˆ 3D åœºæ™¯
      </p>
      <button
        id="skip-btn"
        class="mt-2 text-[11px] text-gray-300 underline decoration-dotted"
      >
        å…ˆçœ‹çœ‹æ•ˆæœï¼Œä¹‹åå†å¼€æ‰‹åŠ¿
      </button>
    </div>
  </div>

  <script>
    // ===== å·¥å…·å‡½æ•°ï¼šå¾®ä¿¡ç¯å¢ƒæ£€æµ‹ =====
    function isWeChat() {
      return /MicroMessenger/i.test(navigator.userAgent || "");
    }

    // ===== Three.js & åœºæ™¯ç›¸å…³ =====
    let scene, camera, renderer, controls;
    let treeGroup = new THREE.Group();
    let scatterGroup = new THREE.Group();
    let snowParticles;
    let clock = new THREE.Clock();

    const STATE = {
      ASSEMBLED: "ASSEMBLED",
      SCATTERED: "SCATTERED",
    };
    let currentState = STATE.ASSEMBLED;
    let targetFactor = 0; // 0 = èšæ‹¢, 1 = é£æ•£
    let currentFactor = 0;

    let currentPhotoSizeSetting = "small";
    let isPanelCollapsed = false;

    const objectData = []; // { mesh, originalPos, scatterPos, originalRot, originalScale, type }

    let photos = [];

    async function initScene() {
      const container = document.getElementById("canvas-container");
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x050a14, 0.018);

      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 500);
      camera.position.set(0, 15, 45);
      camera.lookAt(0, 12, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      const ratio = Math.min(window.devicePixelRatio || 1, 1.8); // é™åˆ¶æœ€å¤§åƒç´ æ¯”
      renderer.setPixelRatio(ratio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(renderer.domElement);

      // Orbit æ§åˆ¶
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.7;
      controls.minDistance = 12;
      controls.maxDistance = 80;
      controls.maxPolarAngle = Math.PI / 2 - 0.05;
      controls.target.set(0, 18, 0);

      // ç¯å…‰ï¼šç¯å¢ƒ + ä¸»å…‰ + æ ‘å†…æš–å…‰
      const ambientLight = new THREE.AmbientLight(0x465360, 0.5);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xddddff, 0.6);
      dirLight.position.set(25, 40, 25);
      dirLight.castShadow = true;
      dirLight.shadow.mapSize.width = 1024;
      dirLight.shadow.mapSize.height = 1024;
      scene.add(dirLight);

      const treeLight = new THREE.PointLight(0xff7733, 2.2, 160);
      treeLight.position.set(0, 14, 0);
      scene.add(treeLight);

      createSimpleFloor();
      createSimpleTree();
      createSnowParticles();

      scene.add(scatterGroup);

      // äº‹ä»¶ç»‘å®š
      window.addEventListener("resize", onWindowResize, false);
      document
        .getElementById("image-upload")
        .addEventListener("change", handleImageUpload, false);
      document
        .getElementById("reset-photos-btn")
        .addEventListener("click", resetPhotos);
      document
        .getElementById("toggle-panel-btn")
        .addEventListener("click", togglePanel);
      document
        .getElementById("panel-minimized")
        .addEventListener("click", togglePanel);
      const header = document.getElementById("panel-header");
      if (header) header.addEventListener("click", togglePanel);

      document
        .querySelectorAll('input[name="photoSize"]')
        .forEach((radio) => {
          radio.addEventListener("change", (e) => {
            currentPhotoSizeSetting = e.target.value;
          });
        });

      // å¾®ä¿¡æç¤º
      if (isWeChat()) {
        const bar = document.getElementById("wechat-tip-bar");
        if (bar) bar.classList.remove("hidden");
      }

      // åŠ è½½é®ç½©ï¼šåªç­‰ 3D åˆå§‹åŒ–ï¼Œå®Œæˆåå°±å…³é—­
      const loadingOverlay = document.getElementById("loading-overlay");
      document.getElementById("skip-btn").addEventListener("click", () => {
        loadingOverlay.classList.add("hidden");
      });

      animate();
    }

    function createSimpleFloor() {
      const geo = new THREE.CircleGeometry(60, 40);
      const mat = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        roughness: 0.85,
        metalness: 0.05,
      });
      const floor = new THREE.Mesh(geo, mat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);
    }

    function createSimpleTree() {
      // æ ‘å¹²
      const trunkGeo = new THREE.CylinderGeometry(1.6, 2.3, 8, 10);
      const trunkMat = new THREE.MeshStandardMaterial({
        color: 0x3a2618,
        roughness: 0.9,
      });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 6;
      trunk.castShadow = true;
      trunk.receiveShadow = true;
      scene.add(trunk);

      // æ ‘å¶ï¼ˆåˆ†å±‚çš„ç®€åŒ–ç‰ˆï¼‰
      const levels = 14;
      const baseRadius = 10;
      const baseHeight = 6;
      const heightSpan = 22;
      const leafColorBase = new THREE.Color(0x1c5a2f);

      for (let i = 0; i < levels; i++) {
        const t = i / (levels - 1);
        const y = baseHeight + t * heightSpan;
        const radius = baseRadius * (1 - t * 0.9) + 1;
        const count = Math.floor(22 + (1 - t) * 6);

        for (let j = 0; j < count; j++) {
          const angle =
            (j / count) * Math.PI * 2 + i * 0.5 + Math.random() * 0.2;
          const rRandom = radius * (0.9 + Math.random() * 0.3);
          const x = Math.cos(angle) * rRandom;
          const z = Math.sin(angle) * rRandom;
          const jitterY = y + (Math.random() - 0.5) * 0.7;

          const geo = new THREE.ConeGeometry(0.8, 3, 5);
          const color = leafColorBase
            .clone()
            .multiplyScalar(0.8 + Math.random() * 0.3);
          const mat = new THREE.MeshStandardMaterial({
            color,
            roughness: 0.85,
            flatShading: true,
          });
          const leaf = new THREE.Mesh(geo, mat);

          const originalPos = new THREE.Vector3(x, jitterY, z);
          const scatterDir = originalPos.clone().normalize();
          const scatterPos = originalPos
            .clone()
            .add(scatterDir.multiplyScalar(18 + Math.random() * 10));

          leaf.position.copy(originalPos);
          leaf.lookAt(x * 1.8, jitterY + 2, z * 1.8);
          leaf.castShadow = true;
          scatterGroup.add(leaf);

          objectData.push({
            mesh: leaf,
            originalPos: originalPos.clone(),
            scatterPos,
            originalRot: leaf.rotation.clone(),
            originalScale: leaf.scale.clone(),
            rotationSpeed: new THREE.Vector3(
              Math.random() * 0.06,
              Math.random() * 0.06,
              0
            ),
            type: "leaf",
          });

          // ç®€å•æŒ‚ä¸€ç‚¹ç¯çƒ
          if (i > 2 && i < levels - 1 && (j + i) % 9 === 0) {
            createSimpleOrnament(originalPos);
          }
        }
      }
    }

    function createSimpleOrnament(pos) {
      const colors = [0xff4444, 0xffd700, 0xffffff, 0x99c2ff];
      const color = colors[Math.floor(Math.random() * colors.length)];
      const isLight = Math.random() > 0.5;

      const geo = new THREE.SphereGeometry(0.4, 12, 12);
      const mat = new THREE.MeshStandardMaterial({
        color,
        roughness: 0.25,
        metalness: 0.7,
        emissive: isLight ? color : 0x000000,
        emissiveIntensity: isLight ? 0.9 : 0,
      });

      const sphere = new THREE.Mesh(geo, mat);
      const offsetDir = pos.clone().normalize();
      const originalPos = pos.clone().add(offsetDir.multiplyScalar(0.8));

      const scatterPos = originalPos
        .clone()
        .add(offsetDir.multiplyScalar(16 + Math.random() * 8));

      sphere.position.copy(originalPos);
      sphere.castShadow = true;
      scatterGroup.add(sphere);

      objectData.push({
        mesh: sphere,
        originalPos: originalPos.clone(),
        scatterPos,
        originalRot: sphere.rotation.clone(),
        originalScale: sphere.scale.clone(),
        rotationSpeed: new THREE.Vector3(
          Math.random() * 0.12,
          Math.random() * 0.12,
          0
        ),
        type: "ornament",
      });
    }

    function createSnowParticles() {
      const count = 800; // è½»é‡ç²’å­
      const geo = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      const speeds = new Float32Array(count);
      const drifts = new Float32Array(count);

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        positions[i3] = (Math.random() - 0.5) * 160;
        positions[i3 + 1] = Math.random() * 80 + 10;
        positions[i3 + 2] = (Math.random() - 0.5) * 160;
        speeds[i] = Math.random() * 0.4 + 0.3;
        drifts[i] = Math.random() * Math.PI * 2;
      }

      geo.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geo.setAttribute("speed", new THREE.BufferAttribute(speeds, 1));
      geo.setAttribute("drift", new THREE.BufferAttribute(drifts, 1));

      const mat = new THREE.PointsMaterial({
        size: 0.7,
        color: 0xffffff,
        transparent: true,
        opacity: 0.8,
        depthWrite: false,
      });

      snowParticles = new THREE.Points(geo, mat);
      scene.add(snowParticles);
    }

    function updateSnow(delta, time) {
      if (!snowParticles) return;
      const positions = snowParticles.geometry.attributes.position.array;
      const speeds = snowParticles.geometry.attributes.speed.array;
      const drifts = snowParticles.geometry.attributes.drift.array;

      for (let i = 0; i < speeds.length; i++) {
        const i3 = i * 3;
        positions[i3 + 1] -= speeds[i] * 7 * delta;
        positions[i3] += Math.sin(time + drifts[i]) * 0.03;
        positions[i3 + 2] += Math.cos(time + drifts[i]) * 0.03;
        if (positions[i3 + 1] < 0) {
          positions[i3 + 1] = 80;
        }
      }
      snowParticles.geometry.attributes.position.needsUpdate = true;
    }

    // ===== ç…§ç‰‡æŒ‚é¥° =====
    function handleImageUpload(e) {
      const files = e.target.files;
      if (!files || !files.length) return;

      const loader = new THREE.TextureLoader();

      Array.from(files).forEach((file) => {
        const reader = new FileReader();
        reader.onload = (ev) => {
          loader.load(ev.target.result, (texture) => {
            texture.encoding = THREE.sRGBEncoding;
            createPhotoCard(texture);
            photos.push(texture);
            document.getElementById(
              "photo-count"
            ).innerText = `å·²æ·»åŠ  ${photos.length} å¼ `;
          });
        };
        reader.readAsDataURL(file);
      });

      e.target.value = "";
    }

    function resetPhotos() {
      for (let i = objectData.length - 1; i >= 0; i--) {
        if (objectData[i].type === "photo") {
          const item = objectData[i];
          scatterGroup.remove(item.mesh);
          if (item.mesh.geometry) item.mesh.geometry.dispose();
          if (item.mesh.material) {
            if (item.mesh.material.map) item.mesh.material.map.dispose();
            item.mesh.material.dispose();
          }
          objectData.splice(i, 1);
        }
      }
      photos = [];
      document.getElementById("photo-count").innerText = "å·²æ·»åŠ  0 å¼ ";
    }

    function createPhotoCard(texture) {
      const img = texture.image;
      const aspect = img.width / img.height;

      let baseSize = 4;
      if (currentPhotoSizeSetting === "medium") baseSize = 5.5;
      if (currentPhotoSizeSetting === "large") baseSize = 7;

      let w = baseSize;
      let h = baseSize / aspect;
      if (h > baseSize) {
        h = baseSize;
        w = baseSize * aspect;
      }

      const geo = new THREE.PlaneGeometry(w, h);
      const mat = new THREE.MeshStandardMaterial({
        map: texture,
        side: THREE.DoubleSide,
        roughness: 0.35,
        metalness: 0.1,
        emissive: 0xffffff,
        emissiveMap: texture,
        emissiveIntensity: 0.18,
      });
      const mesh = new THREE.Mesh(geo, mat);

      const y = 10 + Math.random() * 18;
      const rAtY = 10 * (1 - (y - 6) / 24) + 4;
      const angle = Math.random() * Math.PI * 2;
      const x = Math.cos(angle) * rAtY;
      const z = Math.sin(angle) * rAtY;

      const originalPos = new THREE.Vector3(x, y, z);
      const scatterPos = originalPos
        .clone()
        .add(originalPos.clone().normalize().multiplyScalar(18 + Math.random() * 15));

      mesh.position.copy(originalPos);
      mesh.lookAt(x * 2, y + 2, z * 2);
      scatterGroup.add(mesh);

      objectData.push({
        mesh,
        originalPos,
        scatterPos,
        originalRot: mesh.rotation.clone(),
        originalScale: mesh.scale.clone(),
        rotationSpeed: new THREE.Vector3(
          Math.random() * 0.06,
          Math.random() * 0.06,
          0
        ),
        type: "photo",
      });
    }

    // ===== æŠ˜å é¢æ¿ =====
    function togglePanel() {
      const panel = document.getElementById("main-control-panel");
      const content = document.getElementById("panel-content");
      const minimized = document.getElementById("panel-minimized");
      const btn = document.getElementById("toggle-panel-btn");

      isPanelCollapsed = !isPanelCollapsed;
      if (isPanelCollapsed) {
        content.classList.add("hidden");
        minimized.classList.remove("hidden");
        panel.classList.remove("max-w-md");
        panel.classList.add("w-auto");
        btn.classList.add("rotate-180");
      } else {
        content.classList.remove("hidden");
        minimized.classList.add("hidden");
        panel.classList.add("max-w-md");
        panel.classList.remove("w-auto");
        btn.classList.remove("rotate-180");
      }
    }

    // ===== åŠ¨ç”»å¾ªç¯ =====
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const time = clock.getElapsedTime();

      if (controls) controls.update();

      // èšæ‹¢/é£æ•£æ’å€¼
      const speed = 1.6;
      if (Math.abs(currentFactor - targetFactor) > 0.01) {
        currentFactor += (targetFactor - currentFactor) * speed * delta;
      } else {
        currentFactor = targetFactor;
      }

      objectData.forEach((d) => {
        const { mesh } = d;
        mesh.position.lerpVectors(d.originalPos, d.scatterPos, currentFactor);

        let targetScaleFactor = 1.0;
        if (d.type === "photo") targetScaleFactor = 1.4;
        else if (d.type === "leaf" || d.type === "ornament")
          targetScaleFactor = 0.25;

        const targetScale = d.originalScale
          .clone()
          .multiplyScalar(targetScaleFactor);
        mesh.scale.lerpVectors(d.originalScale, targetScale, currentFactor);

        if (currentFactor > 0.05) {
          mesh.rotation.x += d.rotationSpeed.x * delta * 60;
          mesh.rotation.y += d.rotationSpeed.y * delta * 60;
        } else {
          mesh.rotation.set(
            d.originalRot.x,
            d.originalRot.y,
            d.originalRot.z
          );
        }
      });

      // é›ªèŠ±æ›´æ–°
      updateSnow(delta, time);

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      if (!camera || !renderer) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // ===== MediaPipe æ‰‹åŠ¿è¯†åˆ«ï¼ˆæ‡’åŠ è½½ï¼Œç”¨æˆ·ç‚¹æŒ‰é’®æ‰å¯ç”¨ï¼‰=====
    let handsInstance = null;
    let cameraInstance = null;
    let handStarted = false;

    async function setupMediaPipe() {
      if (handStarted) return;
      handStarted = true;

      const videoEl = document.getElementById("webcam-preview");
      const statusPanel = document.getElementById("gesture-status");
      const statusText = document.getElementById("status-text");
      const statusIcon = document.getElementById("status-icon");
      const loadingOverlay = document.getElementById("loading-overlay");

      videoEl.classList.remove("hidden");
      statusPanel.classList.remove("hidden");
      statusText.innerText = "æ­£åœ¨åŠ è½½æ‰‹åŠ¿æ¨¡å‹â€¦";

      const hands = new Hands({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
      });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.5,
      });
      hands.onResults(onHandResults);

      handsInstance = hands;

      try {
        const cam = new Camera(videoEl, {
          onFrame: async () => {
            await hands.send({ image: videoEl });
          },
          width: 320,
          height: 240,
        });
        cameraInstance = cam;
        await cam.start();

        loadingOverlay.classList.add("hidden");
        statusText.innerText = "å¼ å¼€äº”æŒ‡è¯•è¯• SCATTER é­”æ³•";
        statusIcon.innerText = "ğŸ–ï¸";
      } catch (err) {
        console.error("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥", err);
        loadingOverlay.classList.add("hidden");
        statusText.innerText = "æ‘„åƒå¤´ä¸å¯ç”¨ï¼Œå·²å…³é—­æ‰‹åŠ¿åŠŸèƒ½";
        statusIcon.innerText = "âš ï¸";
        videoEl.classList.add("hidden");
      }
    }

    function onHandResults(results) {
      const statusText = document.getElementById("status-text");
      const statusIcon = document.getElementById("status-icon");
      const statusDiv = document.getElementById("gesture-status");

      if (
        !results.multiHandLandmarks ||
        results.multiHandLandmarks.length === 0
      ) {
        statusText.innerText = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";
        statusIcon.innerText = "ğŸ”";
        return;
      }

      const landmarks = results.multiHandLandmarks[0];
      let extended = 0;

      const dist = (p1, p2) =>
        Math.sqrt(
          (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2 + (p1.z - p2.z) ** 2
        );

      const isFingerExtended = (tipIdx, mcpIdx, wristIdx) => {
        const dTip = dist(landmarks[tipIdx], landmarks[wristIdx]);
        const dMcp = dist(landmarks[mcpIdx], landmarks[wristIdx]);
        return dTip > dMcp;
      };

      if (isFingerExtended(8, 5, 0)) extended++;
      if (isFingerExtended(12, 9, 0)) extended++;
      if (isFingerExtended(16, 13, 0)) extended++;
      if (isFingerExtended(20, 17, 0)) extended++;
      if (dist(landmarks[4], landmarks[17]) > 0.15) extended++;

      if (extended >= 4) {
        if (currentState !== STATE.SCATTERED) {
          currentState = STATE.SCATTERED;
          targetFactor = 1;
          statusText.innerText = "SCATTER Â· æ˜Ÿå…‰é£æ•£";
          statusIcon.innerText = "âœ¨";
          statusDiv.classList.add("bg-yellow-500/20");
          statusDiv.classList.remove("bg-green-500/20");
        }
      } else if (extended <= 1) {
        if (currentState !== STATE.ASSEMBLED) {
          currentState = STATE.ASSEMBLED;
          targetFactor = 0;
          statusText.innerText = "GATHER Â· æ¸©æš–æ±‡èš";
          statusIcon.innerText = "ğŸ„";
          statusDiv.classList.add("bg-green-500/20");
          statusDiv.classList.remove("bg-yellow-500/20");
        }
      } else {
        statusText.innerText = "ä¿æŒæ‰‹åŠ¿æˆ–å†è¯•ä¸€æ¬¡";
      }
    }

    // ===== å¯åŠ¨å…¥å£ =====
    window.addEventListener("DOMContentLoaded", () => {
      initScene();

      const startBtn = document.getElementById("start-btn");
      const loadingOverlay = document.getElementById("loading-overlay");

      startBtn.addEventListener("click", () => {
        startBtn.innerText = "æ­£åœ¨å¼€å¯æ‰‹åŠ¿é­”æ³•â€¦";
        setupMediaPipe();
      });

      // å¦‚æœåœºæ™¯æ¸²æŸ“å·²ç»å¼€å§‹ï¼Œç”¨æˆ·ä¹Ÿå¯ä»¥ç›´æ¥ç‚¹â€œå…ˆçœ‹çœ‹æ•ˆæœâ€
      // loadingOverlay åœ¨ initScene é‡Œä¸ä¼šè‡ªåŠ¨å…³é—­ï¼Œè¿™é‡Œä¿è¯æœ‰æŒ‰é’®å¯å…³
      // ä½ å·²ç»ç»‘å®š skip-btn åœ¨ initScene é‡Œ
    });
  </script>
</body>
</html>
